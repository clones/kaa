#!/usr/bin/python

# python imports
import os
import sys
import gc
import getopt
import time
import logging

# insert freevo path information
__site__ = '../lib/python%s.%s/site-packages' % sys.version_info[:2]
__site__ = os.path.normpath(os.path.join(os.path.dirname(__file__), __site__))
if not __site__ in sys.path:
    sys.path.insert(0, __site__)

# get logging object
log = logging.getLogger('beacon')

def usage(error_code):
    print 'beacon [options]'
    print 'options:'
    print '--start             start beacon'
    print '--stop              stop running beacon'
    print '--db directory      directory of the database (default ~/.beacon)'
    print '--fg                Run in foreground'
    print '--autoshutdown      stop server when no clients are connected'
    print '--logfile file      use file for logging'
    print '--verbose modules   comma separated list of modules which should be more'
    print '                    verbose. Possible modules are db, crawler, monitor,'
    print '                    parser, server. Use \'all\' to increase every module.'
    print '--help | -h         this message'
    print
    print 'Client options:'
    print '--info             displays info about the database'
    print '--search args      search mode'
    print '--monitor          do not exit after search and monitor for changes'
    print '--mount args       mount the query at a given mountpoint (requires FUSE)'
    print '--umount dirname   umounts a beacon fuse mountpoint'
    print
    print 'Examples for client mode when a server is running:'
    print '  beacon --search dirname=/local/video'
    print '  beacon --search --monitor dirname=/local/video'
    print '  beacon --search artist=Silbermond'
    print '  beacon --search attr=album type=audio'
    print '  beacon --search "keywords=Helden Blind"'
    print '  beacon --mount ~/buffy keywords=buffy'
    sys.exit(error_code)

    
try:
    # read arguments
    opts = [ 'start', 'stop', 'db=', 'fg', 'autoshutdown', 'logfile=',
             'verbose=', 'help', 'search', 'monitor', 'info', 'mount',
             'umount' ]
    opts, args = getopt.getopt(sys.argv[1:], 'h', opts)
except getopt.GetoptError:
    usage(1)

logfile  = ''
mountpt  = ''
mode     = None
detach   = True
shutdown = False
monitor  = False
database = os.path.expanduser("~/.beacon")

for o, a in opts:
    if o in ('--start', '--stop', '--search', '--info', '--mount', '--umount'):
        if mode:
            usage(1)
        mode = o[2:]
    elif o == '--db':
        database = a
    elif o == '--fg':
        detach = False
    elif o == '--autoshutdown':
        shutdown = True
    elif o == '--logfile':
        logfile = a
    elif o == '--verbose':
        a = a.lower()
        if a == 'all':
            logging.getLogger('beacon').setLevel(logging.INFO)
        else:
            for m in a.split(','):
                logging.getLogger('beacon.' + m).setLevel(logging.INFO)
    elif o == '--monitor':
        monitor = True
    elif o in ('--help', '-h'):
        usage(0)

if not mode:
    # no idea what to do
    usage(0)

if mode == 'stop':
    # stop a running beacon
    
    import kaa.notifier
    import kaa.beacon.client
    import socket

    def shutdown(client):
        client.rpc('beacon.shutdown')()
        kaa.notifier.step()
        sys.exit(0)

    try:
        client = kaa.beacon.Client()
        client.signals['connect'].connect(shutdown, client)
    except socket.error: # FIXME: beacon needs an exception class for this.
        print 'server not running'
        sys.exit(1)
    kaa.notifier.loop()
    sys.exit(0)

if mode == 'umount':
    mountpt = args.pop(0)
    os.system('fusermount -u %s' % mountpt)
    sys.exit(0)
    
if mode in ("search", "info", "mount"):
    # client info/search mode

    import kaa.notifier
    import kaa.beacon
    try:
        kaa.beacon.connect()
    except Exception, e:
        print 'beacon server not running'
        sys.exit(1)
    
if mode == "info":

    info = kaa.beacon.get_db_info()
    print 'Beacon database information:'
    print
    print 'Total objects:'.rjust(20), info['total']
    print 'Indexed keywords:'.rjust(20), info['wordcount']
    print
    print 'Object breakdown by type:'
    for key in info['count']:
        print (key + ':').rjust(15), info['count'][key]
    sys.exit(0)

if mode == 'mount':
    mountpt = args.pop(0)
    if not os.path.isdir(mountpt):
        print "Mount point %s is not a directory" % mountpt
        sys.exit(1)

if mode in ('search', 'mount'):

    def progress(cur, total, item):
        n = 0
        if total > 0:
            n = int((cur / float(total)) * 50)
        sys.stdout.write("|%51s| %d / %d\r" % (("="*n + ">").ljust(51), cur, total))
        sys.stdout.flush()
        if cur == total:
            print

    def changed(result):
        print 'Beacon query update'
        for r in result:
            print r

    def uptodate():
        print 'Beacon has finished the query and parsing'

 
    query   = {}
    for a in args:
        key, value = a.split('=', 1)
        if key in ('title', 'album', 'artist'):
            value = unicode(value)
        elif key in ('limit',):
            value = int(value)
        if isinstance(value, basestring) and "%" in value:
            # Treat as wildcard search, use LIKE operator.
            query[key] = kaa.db.QExpr("like", "%%%s%%" % value)
        else:
            query[key] = value

    t1 = time.time()
    if 'dirname' in query:
        if 'recursive' in query:
            result = kaa.beacon.get(query['dirname']).listdir(recursive=True)
        else:
            result = kaa.beacon.get(query['dirname']).listdir()
    else:
        result = kaa.beacon.query(**query)

    if mode == 'mount':
        from kaa.beacon.fusefs import BeaconFS
        fs = BeaconFS(mountpt, result)
        fs.check()
        if detach:
            if not logfile:
                logfile = os.path.join(database, 'fuse.log')
                print "Using default logfile of", logfile
            # FIXME: should only daemonize when we know fs is mounted.
            kaa.utils.daemonize(stdout=logfile)

        thread = kaa.notifier.Thread(fs.main)
        thread.signals["exception"].connect(lambda dummy: kaa.notifier.shutdown())
        thread.start()

        kaa.notifier.loop()
        sys.exit(0)


    if not monitor or result.valid:
        len(result)
        t2 = time.time()

        for r in result:
            print r
        print 'Query took %s seconds; %d results' % ((t2-t1), len(result))
        sys.exit(0)
    result.signals['changed'].connect(changed, result)
    result.signals['progress'].connect(progress)
    result.signals['up-to-date'].connect(uptodate)
    result.monitor()
    kaa.notifier.loop()
    sys.exit(0)

    
# When we reach this point we need to start a new beacon server. If run
# in daemon mode we fork and detach from the parent. After that a logger
# is created and the thumbnail server will be forked out.

import kaa.utils

if detach:
    logfile = os.path.join(database, 'server.log')
    if not logfile:
        logfile = os.path.join(database, 'server.log')
        print 'Using default logfile of', logfile

    kaa.utils.daemonize()
    
# create logger
if logfile:
    if not os.path.isdir(os.path.dirname(logfile)):
        os.makedirs(os.path.dirname(logfile))
    handler = logging.FileHandler(logfile)
    f = logging.Formatter('%(asctime)s %(levelname)-8s [%(name)6s] '+\
                          '%(filename)s %(lineno)s: %(message)s')
    handler.setFormatter(f)
    log.addHandler(handler)
    
# fork thumbnailer
pid = os.fork()
if not pid:
    # thumbnailer child
    import kaa.beacon.thumbnail.server
    kaa.beacon.thumbnail.server.loop()
    sys.exit(0)
    

# beacon server
import kaa
import kaa.notifier

import kaa.beacon.server
import kaa.beacon.thumbnail

def garbage_collect():
    g = gc.collect()
    if g:
        log.info('gc: deleted %s objects' % g)
    if gc.garbage:
        log.warning('gc: found %s garbage objects' % len(gc.garbage))
        for g in gc.garbage:
            log.warning(g)
    return True


# connect thumbnailer
log.info('connect to thumbnailer ...')
kaa.beacon.thumbnail.connect()
log.info('connection to thumbnailer established')

server = kaa.beacon.server.Server(database)
if os.environ.get('BEACON_MONITOR'):
    for dirname in os.environ.get('BEACON_MONITOR').split(':'):
        log.info('monitor %s', dirname)
        server.monitor_dir(dirname)
            
# start garbage collector
kaa.notifier.Timer(garbage_collect).start(10)
if shutdown:
    log.info('set autoshutdown timer to 3 seconds')
    server.autoshutdown(3)

kaa.notifier.loop()
log.info('stop beacon')

kaa.beacon.thumbnail.stop()

#wait for dead thumbnailer
os.waitpid(pid, 0)
print 'Beacon done.'
